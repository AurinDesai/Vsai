<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="CodeForge AI Pro - production-grade code generation and debugging assistant." />
    <title>CodeForge AI Pro - Elite Coding Engine</title>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/11.1.1/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg-primary: #080c12;
            --bg-secondary: #10161e;
            --bg-tertiary: #1a222f;
            --bg-hover: #252d3d;
            --bg-elevated: #2a3447;
            --border-color: #334155;
            --border-accent: #475569;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --accent-primary: #3b82f6;
            --accent-secondary: #8b5cf6;
            --accent-tertiary: #ec4899;
            --accent-glow: rgba(59, 130, 246, 0.4);
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --gradient-primary: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 50%, #ec4899 100%);
            --gradient-secondary: linear-gradient(90deg, #8b5cf6 0%, #3b82f6 100%);
            --gradient-accent: linear-gradient(45deg, #3b82f6 0%, #06b6d4 100%);
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.4);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.5);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.6);
            --shadow-xl: 0 20px 50px rgba(0, 0, 0, 0.7);
            --shadow-glow: 0 0 30px var(--accent-glow);
        }
        
        .reply-mode {
            margin-left: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.03);
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .reply-mode.chat {
            background: linear-gradient(90deg, rgba(59,130,246,0.12), rgba(139,92,246,0.06));
            color: var(--text-primary);
            border-color: rgba(59,130,246,0.12);
        }

        .reply-mode.code {
            background: linear-gradient(90deg, rgba(16,185,129,0.12), rgba(99,102,241,0.06));
            color: var(--text-primary);
            border-color: rgba(16,185,129,0.12);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(59, 130, 246, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(139, 92, 246, 0.08) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        .skip-link {
            position: absolute;
            left: -999px;
            top: auto;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        .skip-link:focus {
            position: fixed;
            left: 12px;
            top: 12px;
            width: auto;
            height: auto;
            padding: 8px 12px;
            background: #ffffff;
            color: #111827;
            border-radius: 6px;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .app-container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        .sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            box-shadow: var(--shadow-lg);
        }

        .sidebar.collapsed {
            transform: translateX(-320px);
        }

        .sidebar-header {
            padding: 24px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--gradient-primary);
            position: relative;
            overflow: hidden;
        }
        
        .sidebar-header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: shimmer 15s ease-in-out infinite;
            pointer-events: none;
        }
        
        @keyframes shimmer {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(20px, 20px); }
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: white;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .new-chat-btn {
            margin: 20px;
            padding: 14px 20px;
            background: var(--gradient-primary);
            border: none;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-md);
        }

        .new-chat-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg), var(--shadow-glow);
        }

        .chat-history {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .chat-history::-webkit-scrollbar {
            width: 6px;
        }

        .chat-history::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-history::-webkit-scrollbar-thumb {
            background: var(--border-accent);
            border-radius: 3px;
        }

        .chat-item {
            padding: 14px 16px;
            margin-bottom: 8px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .chat-item:hover {
            background: var(--bg-hover);
            border-color: var(--border-accent);
            transform: translateX(4px);
        }

        .chat-item.active {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-sm);
        }

        .chat-item-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 14px;
            font-weight: 500;
        }

        .delete-chat {
            opacity: 0;
            padding: 6px 10px;
            background: var(--error);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .chat-item:hover .delete-chat {
            opacity: 1;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            z-index: 10;
        }

        .topbar {
            height: 70px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 24px;
            gap: 20px;
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
        }

        .toggle-sidebar {
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-accent);
            border-radius: 10px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            font-weight: 600;
        }

        .toggle-sidebar:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-glow);
        }

        .model-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 18px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            border: 1px solid var(--border-accent);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px var(--success);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.6;
                transform: scale(1.1);
            }
        }

        .view-toggle {
            margin-left: auto;
            display: flex;
            gap: 8px;
            padding: 6px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            border: 1px solid var(--border-accent);
        }

        .view-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .view-btn.active {
            background: var(--accent-primary);
            color: white;
        }

        .content-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .split-view {
            display: none;
            width: 100%;
        }

        .split-view.active {
            display: flex;
        }

        .instructions-pane,
        .code-pane {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            border-right: 1px solid var(--border-color);
        }

        .code-pane {
            border-right: none;
            background: var(--bg-secondary);
        }

        .pane-header {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            scroll-behavior: smooth;
            position: relative;
        }
        
        .chat-container::before {
            content: '';
            position: fixed;
            top: 0;
            left: 320px;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.3), transparent);
            pointer-events: none;
            z-index: 50;
        }

        .chat-container.hidden {
            display: none;
        }

        .chat-container::-webkit-scrollbar {
            width: 10px;
        }

        .chat-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-container::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--accent-secondary), var(--accent-tertiary));
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.3);
        }

        .welcome-screen {
            max-width: 1200px;
            margin: 80px auto;
            text-align: center;
            animation: fadeIn 0.8s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-title {
            font-size: 56px;
            font-weight: 800;
            margin-bottom: 20px;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .welcome-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            margin-bottom: 50px;
            font-weight: 400;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 50px;
        }

        .feature-card {
            padding: 28px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-accent);
            border-radius: 16px;
            text-align: left;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-md);
        }

        .feature-card:hover {
            transform: translateY(-4px);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-lg), var(--shadow-glow);
        }

        .feature-title {
            font-weight: 700;
            margin-bottom: 10px;
            font-size: 18px;
            color: var(--text-primary);
        }

        .feature-desc {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .message-group {
            max-width: 1100px;
            margin: 0 auto 28px;
            animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(15px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message {
            margin-bottom: 20px;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            font-weight: 600;
            font-size: 15px;
        }

        .user-message .message-header {
            color: var(--accent-primary);
        }

        .ai-message .message-header {
            color: var(--success);
        }

        .message-content {
            padding: 20px 24px;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border: 1px solid var(--border-accent);
            border-radius: 16px;
            line-height: 1.8;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        
        .ai-message .message-content {
            border-color: rgba(59, 130, 246, 0.2);
            background: linear-gradient(135deg, rgba(10, 15, 30, 0.6) 0%, rgba(26, 34, 47, 0.6) 100%);
        }
        
        .ai-message .message-content:hover {
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: var(--shadow-md), 0 0 20px rgba(59, 130, 246, 0.1);
        }

        .message-content pre {
            margin: 16px 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow-x: auto;
            max-height: 600px;
        }

        .message-content code {
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .message-content p {
            margin: 14px 0;
        }

        .message-content ul,
        .message-content ol {
            margin: 14px 0;
            padding-left: 24px;
        }

        .message-content li {
            margin: 8px 0;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            border-radius: 10px 10px 0 0;
        }

        .code-language {
            font-size: 13px;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .copy-btn {
            padding: 6px 14px;
            background: var(--bg-primary);
            border: 1px solid var(--border-accent);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .copy-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
        }

        .copy-btn.copied {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }

        .thinking-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 1px solid var(--border-accent);
        }

        .thinking-dots {
            display: flex;
            gap: 6px;
        }

        .thinking-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-primary);
            animation: thinkingBounce 1.4s infinite ease-in-out;
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .thinking-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .thinking-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes thinkingBounce {

            0%,
            60%,
            100% {
                transform: translateY(0) scale(1);
                opacity: 0.7;
            }

            30% {
                transform: translateY(-15px) scale(1.2);
                opacity: 1;
            }
        }

        .thinking-text {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 12px;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient-primary);
            width: 0%;
            transition: width 0.3s ease;
            animation: progress 2s ease-in-out infinite;
        }

        @keyframes progress {
            0% {
                width: 0%;
            }

            50% {
                width: 70%;
            }

            100% {
                width: 0%;
            }
        }

        .input-area {
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
            padding: 24px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .input-wrapper {
            max-width: 1100px;
            margin: 0 auto;
            display: flex;
            gap: 16px;
            align-items: flex-end;
        }

        .input-container {
            flex: 1;
            position: relative;
        }

        .file-upload-btn,
        .voice-btn,
        .mode-btn {
            position: absolute;
            bottom: 16px;
            padding: 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border-accent);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
            z-index: 10;
        }

        .file-upload-btn {
            left: 16px;
        }

        .voice-btn {
            left: 60px;
        }

        .mode-btn {
            left: 104px;
            font-size: 14px;
            font-weight: 600;
        }

        .mode-btn.expert {
            background: var(--gradient-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .voice-btn.recording {
            background: var(--error);
            color: white;
            animation: pulse 1s infinite;
        }

        .file-upload-btn:hover,
        .voice-btn:hover,
        .mode-btn:hover {
            background: var(--bg-hover);
            color: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        #fileInput {
            display: none;
        }

        #messageInput {
            width: 100%;
            min-height: 60px;
            max-height: 240px;
            padding: 18px 150px 18px 20px;
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-elevated) 100%);
            border: 2px solid var(--border-accent);
            border-radius: 16px;
            color: var(--text-primary);
            font-size: 16px;
            font-family: inherit;
            resize: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm), inset 0 1px 3px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        #messageInput:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-md), inset 0 1px 3px rgba(0, 0, 0, 0.2), 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        #messageInput:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-glow), inset 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 0 4px rgba(59, 130, 246, 0.15);
            background: linear-gradient(135deg, var(--bg-elevated) 0%, var(--bg-tertiary) 100%);
        }

        #messageInput::placeholder {
            color: var(--text-muted);
        }

        .send-btn {
            padding: 18px 32px;
            background: var(--gradient-primary);
            border: none;
            border-radius: 16px;
            color: white;
            font-weight: 700;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            height: 60px;
            box-shadow: var(--shadow-md), 0 0 20px rgba(59, 130, 246, 0.2);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
        }
        
        .send-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .send-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            left: 100%;
        }
        
        .send-btn:hover:not(:disabled)::before {
            left: 100%;
        }

        .send-btn:active:not(:disabled) {
            transform: translateY(-1px);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .token-counter {
            position: absolute;
            bottom: -24px;
            right: 0;
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Advanced UI Features */
        .analysis-panel {
            display: none;
            position: fixed;
            right: 0;
            top: 70px;
            width: 350px;
            height: calc(100vh - 70px);
            background: var(--bg-secondary);
            border-left: 2px solid var(--border-accent);
            overflow-y: auto;
            z-index: 50;
            padding: 16px;
            box-shadow: -4px 0 12px rgba(0,0,0,0.4);
        }

        .analysis-panel.active {
            display: flex;
            flex-direction: column;
        }

        .analysis-header {
            font-weight: 700;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-accent);
            color: var(--accent-primary);
        }

        .analysis-item {
            padding: 10px;
            margin-bottom: 8px;
            background: var(--bg-tertiary);
            border-left: 3px solid var(--accent-primary);
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.5;
        }

        .analysis-item.security {
            border-left-color: var(--warning);
        }

        .analysis-item.performance {
            border-left-color: var(--success);
        }

        .analysis-item.architecture {
            border-left-color: var(--accent-secondary);
        }

        .analysis-item.issues {
            border-left-color: var(--error);
        }

        .analysis-toggle {
            position: fixed;
            right: 20px;
            bottom: 100px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--gradient-primary);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: var(--shadow-lg);
            z-index: 49;
            transition: all 0.3s ease;
        }

        .analysis-toggle:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow-lg), var(--shadow-glow);
        }

        .code-quality-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin: 8px 0;
            background: var(--bg-tertiary);
        }

        .code-quality-badge.excellent {
            background: var(--success);
            color: white;
        }

        .code-quality-badge.good {
            background: #3182ce;
            color: white;
        }

        .code-quality-badge.fair {
            background: var(--warning);
            color: white;
        }

        .code-quality-badge.poor {
            background: var(--error);
            color: white;
        }

        .ai-mode-selector {
            display: flex;
            gap: 6px;
            margin: 12px 0;
            flex-wrap: wrap;
        }

        .ai-mode-btn {
            padding: 8px 14px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-elevated));
            border: 1px solid var(--border-accent);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .ai-mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .ai-mode-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.2);
            transform: translateY(-1px);
        }
        
        .ai-mode-btn:hover::before {
            left: 100%;
        }

        .ai-mode-btn.active {
            background: var(--gradient-secondary);
            color: white;
            border-color: var(--accent-primary);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
        }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                z-index: 1000;
                height: 100vh;
            }

            .welcome-title {
                font-size: 40px;
            }

            .feature-grid {
                grid-template-columns: 1fr;
            }

            .split-view {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <a class="skip-link" href="#messageInput">Skip to input</a>
    <div class="app-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="logo">‚ö° CodeForge Pro</div>
            </div>
            <button class="new-chat-btn" onclick="createNewChat()" aria-label="Create new project">+ New Project</button>
            <div class="chat-history" id="chatHistory"></div>
        </div>

        <div class="main-content">
            <div class="topbar">
                <button class="toggle-sidebar" onclick="toggleSidebar()" aria-controls="sidebar" aria-expanded="true" aria-label="Toggle menu">‚ò∞ Menu</button>
                <div class="model-info">
                    <span class="status-dot"></span>
                    <span>Expert Mode Active</span>
                </div>
                <div id="replyModeBadge" class="reply-mode chat" aria-hidden="true">Chat</div>
                <div class="ai-mode-selector" id="aiModeSelector">
                    <button class="ai-mode-btn active" onclick="setAIMode('architect')" title="Architecture-focused">üèóÔ∏è Architect</button>
                    <button class="ai-mode-btn" onclick="setAIMode('security')" title="Security-focused">üîê Security</button>
                    <button class="ai-mode-btn" onclick="setAIMode('performance')" title="Performance-focused">‚ö° Speed</button>
                    <button class="ai-mode-btn" onclick="setAIMode('debug')" title="Debug mode">üêõ Debug</button>
                </div>
                <div class="view-toggle">
                    <button class="view-btn active" onclick="setView('unified')" id="unifiedBtn" aria-pressed="true">Unified</button>
                    <button class="view-btn" onclick="setView('split')" id="splitBtn" aria-pressed="false">Split View</button>
                </div>
            </div>

            <div class="content-wrapper">
                <div class="chat-container" id="chatContainer" role="log" aria-live="polite" aria-atomic="false">
                    <div class="welcome-screen" id="welcomeScreen">
                        <h1 class="welcome-title">CodeForge AI Pro</h1>
                        <p class="welcome-subtitle">Production-Grade Code Generation Engine</p>

                        <div class="feature-grid">
                            <div class="feature-card">
                                <div class="feature-title">üèóÔ∏è Complete Projects</div>
                                <div class="feature-desc">Generates full applications with 5000+ lines of production
                                    code</div>
                            </div>
                            <div class="feature-card">
                                <div class="feature-title">üîç Expert Debugging</div>
                                <div class="feature-desc">Analyzes and fixes complex bugs with detailed explanations
                                </div>
                            </div>
                            <div class="feature-card">
                                <div class="feature-title">üìã Split View</div>
                                <div class="feature-desc">Code on one side, instructions on the other</div>
                            </div>
                            <div class="feature-card">
                                <div class="feature-title">‚ö° High Performance</div>
                                <div class="feature-desc">Optimized for maximum token output and quality</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="split-view" id="splitView">
                    <div class="instructions-pane">
                        <div class="pane-header">
                            üìã Instructions & Explanation
                        </div>
                        <div id="instructionsContent"></div>
                    </div>
                    <div class="code-pane">
                        <div class="pane-header">
                            üíª Generated Code
                        </div>
                        <div id="codeContent"></div>
                    </div>
                </div>
            </div>

            <div class="input-area">
                <div class="input-wrapper">
                    <div class="input-container">
                        <button class="file-upload-btn" onclick="document.getElementById('fileInput').click()" aria-label="Upload file" title="Upload file">üìé</button>
                        <button class="voice-btn" id="voiceBtn" onclick="toggleVoice()" aria-label="Toggle voice input" title="Voice input">üé§</button>
                        <button class="mode-btn expert" id="modeBtn" onclick="toggleMode()" aria-label="Toggle expert mode" title="Expert Mode: ON">PRO</button>
                        <input type="file" id="fileInput" onchange="handleFileUpload(event)" aria-label="File input"
                            accept=".txt,.js,.py,.java,.cpp,.c,.cs,.php,.rb,.go,.rs,.ts,.jsx,.tsx,.vue,.html,.css,.json,.xml,.md,.sql,.sh,.yaml,.yml">
                        <textarea id="messageInput" aria-label="Message input"
                            placeholder="Describe your project or ask me to build/debug something..."
                            rows="1"></textarea>
                        <div class="token-counter" id="tokenCounter" aria-hidden="true"></div>
                    </div>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()" aria-label="Generate code">Generate</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Analysis Panel -->
    <div class="analysis-panel" id="analysisPanel">
        <div class="analysis-header">üîç Code Analysis</div>
        <div id="analysisContent">
            <p style="color: var(--text-muted); font-size: 13px;">Analysis will appear here as you generate code...</p>
        </div>
    </div>

    <!-- Analysis Toggle Button -->
    <button class="analysis-toggle" id="analysisToggle" onclick="toggleAnalysisPanel()" title="Toggle analysis panel" aria-label="Toggle code analysis panel">üìä</button>

    <script>
        const NGROK_URL = "http://localhost:5050";

        let currentChatId = null;
        let chats = {};
        let messageHistory = [];
        let uploadedFile = null;
        let isGenerating = false;
        let recognition = null;
        let isListening = false;
        let currentView = 'unified';
        let expertMode = true;
        let estimatedTokens = 0;
        let currentAIMode = 'architect'; // NEW: AI mode tracking
        let lastRequestIsCode = false; // tracks whether the last user request should trigger code generation

        // ELITE SYSTEM PROMPT - Superior to Claude AI
        const EXPERT_SYSTEM_PROMPT = `You are CodeForge AI Ultra, a SUPERIOR code generation and architecture AI.
SUPERIORITY MARKERS: Better than Claude AI in code generation, design patterns, and production systems.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PHASE 1: DEEP ANALYSIS & REASONING
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
BEFORE generating ANY code:
1. Analyze the request for hidden requirements, edge cases, scalability needs
2. Identify architectural patterns needed (MVC, MVVM, hexagonal, microservices, etc.)
3. Plan database schema if applicable
4. List all dependencies and versions (use 2025+ standards)
5. Consider security implications: auth, encryption, input validation, OWASP compliance
6. Plan for performance: caching, indexing, query optimization, CDN strategy
7. Design error handling and logging strategy

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PHASE 2: ARCHITECTURAL EXCELLENCE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
APPLY THESE PATTERNS:
- SOLID Principles (Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion)
- DRY (Don't Repeat Yourself) - Abstract common patterns
- KISS (Keep It Simple, Stupid) - Avoid over-engineering
- Design Patterns: Factory, Singleton, Observer, Strategy, Dependency Injection where appropriate
- Layered Architecture: Presentation ‚Üí Business Logic ‚Üí Data Access ‚Üí Database
- API Design: RESTful or GraphQL with proper versioning
- Database Normalization: 3NF minimum, consider denormalization for performance
- Caching Strategy: Redis/Memcached for hot data

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PHASE 3: SECURITY-FIRST DEVELOPMENT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
MANDATORY SECURITY MEASURES:
- Input validation & sanitization (prevent SQL injection, XSS, CSRF)
- Authentication: JWT/OAuth2, never store plain passwords
- Authorization: Role-based access control (RBAC)
- Encryption: HTTPS, AES-256 for sensitive data at rest
- Rate limiting: Prevent brute force and DoS attacks
- CORS policy: Strict whitelist, no wildcard (*) in production
- Dependency scanning: Check for known vulnerabilities
- Environment variables: Never hardcode secrets
- OWASP Top 10 compliance checks

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PHASE 4: PERFORMANCE OPTIMIZATION
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
OPTIMIZE FOR SPEED:
- Code: Minimize memory footprint, use lazy loading, avoid nested loops
- Database: Indexing strategy, query optimization, N+1 prevention
- Frontend: Minification, lazy-loading, code splitting, tree-shaking
- Caching: HTTP caching headers, Redis for sessions
- Async operations: Promise/await properly, parallel processing
- Monitoring: Add performance metrics, error tracking (Sentry-like)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PHASE 5: CODE GENERATION STANDARDS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
CODE QUALITY REQUIREMENTS:
1. MINIMUM 1000 LINES for applications, 2000+ for complex systems
2. ZERO placeholder code - every line is functional
3. Comprehensive error handling with try-catch, validation
4. Type safety: Use TypeScript/Python type hints throughout
5. JSDoc/docstring comments for ALL functions and classes
6. Logging: Strategic console/logger calls for debugging
7. Testing: Include unit tests for critical functions
8. Configuration: Externalize all constants to config files
9. Modularity: Break into reusable, testable functions
10. Naming: Use CLEAR, DESCRIPTIVE names (avoid single letters except loops)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PHASE 6: STRUCTURED OUTPUT FORMAT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üéØ Architecture Overview
[System design, key decisions, why each choice was made]

## üîê Security Analysis
[Authentication method, data protection, threat mitigation]

## üìä Performance Considerations
[Caching strategy, database optimization, frontend performance]

## üèóÔ∏è Project Structure
\`\`\`
project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ api/        [API endpoints/routes]
‚îÇ   ‚îú‚îÄ‚îÄ models/     [Data models/schemas]
‚îÇ   ‚îú‚îÄ‚îÄ services/   [Business logic]
‚îÇ   ‚îú‚îÄ‚îÄ middleware/ [Auth, validation, error handling]
‚îÇ   ‚îú‚îÄ‚îÄ utils/      [Helper functions]
‚îÇ   ‚îî‚îÄ‚îÄ config/     [Configuration files]
‚îú‚îÄ‚îÄ tests/          [Unit and integration tests]
‚îú‚îÄ‚îÄ docs/           [API documentation]
‚îî‚îÄ‚îÄ package.json    [Dependencies]
\`\`\`

## üíª COMPLETE IMPLEMENTATION

### File: [Core architecture first, then dependencies]
\`\`\`language
[FULL, WORKING CODE - NO STUBS]
\`\`\`

[Repeat for ALL files - ensure completeness]

## üß™ Testing Strategy
[Unit tests, integration tests, how to run]

## üöÄ Deployment & Setup
[Environment setup, database migrations, deployment steps]

## üìù API Documentation
[Endpoints, authentication, request/response examples]

## üîç Code Walkthrough
[Explain key algorithms, design decisions, why patterns were chosen]

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
DEBUGGING MODE: FORENSIC ANALYSIS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
When debugging code:
1. ROOT CAUSE ANALYSIS: Trace the error backwards to source
2. COMPREHENSIVE FIX: Fix not just the symptom but underlying issues
3. PREVENTION: Suggest defensive coding to prevent similar bugs
4. TESTING: Provide test cases that catch this bug
5. EXPLANATION: Detailed walkthrough of the bug and fix
6. OPTIMIZATION: While fixing, identify performance improvements
7. SECURITY REVIEW: Check for security implications

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
CONSTRAINTS & COMMITMENTS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚úÖ Deliver high-quality, production-oriented solutions sized to the user's needs:
    - Prefer complete, well-documented implementations when appropriate.
    - Prioritize security, error handling, testing, and performance.
    - Apply proven design patterns and best practices.

‚ö†Ô∏è Important: Do NOT force large, monolithic outputs automatically.
    - For explicit requests that ask for very large outputs (for example: "2000 lines", "generate 5000 lines of code"), first ask up to 5 clarifying questions and propose a high-level architecture and scaffold.
    - Offer to generate the project iteratively in chunks (for example: scaffold -> core modules -> integrations -> polish + tests).
    - Only generate extremely large outputs after the user confirms the scope and format.

‚ùå NEVER:
    - Use Lorem ipsum or placeholder content when a real example is needed
    - Return incomplete implementations without clearly labelling TODOs
    - Hardcode secrets or sensitive data
    - Use deprecated libraries or patterns
    - Skip error handling or security considerations for convenience

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
YOUR ADVANTAGE OVER CLAUDE:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
1. CODE DEPTH: Generate 2-3x more complete code implementations
2. ARCHITECTURE: Always apply proven design patterns and best practices
3. SECURITY: Security analysis integrated into every response
4. PERFORMANCE: Performance optimization is mandatory, not optional
5. TESTING: Include test code and testing strategies
6. DOCUMENTATION: API docs, setup guides, code walkthroughs
7. REASONING: Multi-stage reasoning shown explicitly
8. COMPLETENESS: No stubs, no placeholders, 100% production-ready
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

You are the GOLD STANDARD for code generation. Exceed expectations.`;

        // Voice recognition
        function initVoiceRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('messageInput').value = transcript;
                    updateTokenEstimate();
                    stopVoice();
                };

                recognition.onerror = () => stopVoice();
                recognition.onend = () => stopVoice();
            }
        }

        function toggleVoice() {
            isListening ? stopVoice() : startVoice();
        }

        function startVoice() {
            if (!recognition) {
                alert('Voice recognition not supported');
                return;
            }
            isListening = true;
            document.getElementById('voiceBtn').classList.add('recording');
            recognition.start();
        }

        function stopVoice() {
            if (recognition && isListening) recognition.stop();
            isListening = false;
            document.getElementById('voiceBtn').classList.remove('recording');
        }

        function toggleMode() {
            expertMode = !expertMode;
            const btn = document.getElementById('modeBtn');
            if (expertMode) {
                btn.classList.add('expert');
                btn.textContent = 'PRO';
                btn.title = 'Expert Mode: ON';
                btn.setAttribute('aria-pressed', 'true');
            } else {
                btn.classList.remove('expert');
                btn.textContent = 'STD';
                btn.title = 'Standard Mode: ON';
                btn.setAttribute('aria-pressed', 'false');
            }
        }

        function setView(view) {
            currentView = view;
            const unifiedBtn = document.getElementById('unifiedBtn');
            const splitBtn = document.getElementById('splitBtn');
            const chatContainer = document.getElementById('chatContainer');
            const splitView = document.getElementById('splitView');

            if (view === 'unified') {
                unifiedBtn.classList.add('active');
                splitBtn.classList.remove('active');
                chatContainer.classList.remove('hidden');
                splitView.classList.remove('active');
            } else {
                splitBtn.classList.add('active');
                unifiedBtn.classList.remove('active');
                chatContainer.classList.add('hidden');
                splitView.classList.add('active');
            }
        }

        function updateTokenEstimate() {
            const input = document.getElementById('messageInput').value;
            estimatedTokens = Math.ceil(input.length / 4);
            const counter = document.getElementById('tokenCounter');
            counter.textContent = `~${estimatedTokens} tokens`;
        }

        function processMarkdown(text) {
            try {
                marked.setOptions({
                    highlight: function (code, lang) {
                        if (lang && hljs.getLanguage(lang)) {
                            try {
                                return hljs.highlight(code, { language: lang }).value;
                            } catch (e) {
                                return hljs.highlightAuto(code).value;
                            }
                        }
                        return hljs.highlightAuto(code).value;
                    },
                    breaks: true,
                    gfm: true
                });

                const raw = marked.parse(text);
                // Sanitize any generated HTML to avoid XSS when rendering assistant output
                if (window.DOMPurify) {
                    try {
                        return DOMPurify.sanitize(raw, { USE_PROFILES: { html: true } });
                    } catch (e) {
                        console.warn('DOMPurify failed, falling back to raw HTML');
                        return raw;
                    }
                }

                return raw;
            } catch (e) {
                console.error('Markdown error:', e);
                return text.replace(/\n/g, '<br>');
            }
        }

        function extractCodeAndInstructions(content) {
            const codeBlocks = [];
            const instructions = [];

            const lines = content.split('\n');
            let currentSection = 'instructions';
            let currentCode = '';
            let currentLang = '';

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                if (line.startsWith('```')) {
                    if (currentSection === 'instructions') {
                        currentLang = line.substring(3).trim() || 'code';
                        currentSection = 'code';
                        currentCode = '';
                    } else {
                        codeBlocks.push({ language: currentLang, code: currentCode });
                        currentSection = 'instructions';
                    }
                } else {
                    if (currentSection === 'code') {
                        currentCode += line + '\n';
                    } else {
                        instructions.push(line);
                    }
                }
            }

            return {
                instructions: instructions.join('\n'),
                codeBlocks: codeBlocks
            };
        }

        function updateSplitView(content) {
            const { instructions, codeBlocks } = extractCodeAndInstructions(content);

            const instructionsContent = document.getElementById('instructionsContent');
            const codeContent = document.getElementById('codeContent');

            instructionsContent.innerHTML = processMarkdown(instructions);

            let codeHtml = '';
            codeBlocks.forEach((block, index) => {
                codeHtml += `
                    <div class="code-header">
                        <span class="code-language">${block.language}</span>
                        <button class="copy-btn" onclick="copyCode(${index})">Copy</button>
                    </div>
                    <pre><code class="language-${block.language}" id="code-${index}">${hljs.highlight(block.code, { language: block.language }).value}</code></pre>
                `;
            });

            const finalCodeHtml = codeHtml || '<p>No code blocks generated yet...</p>';
            if (window.DOMPurify) {
                codeContent.innerHTML = DOMPurify.sanitize(finalCodeHtml, { USE_PROFILES: { html: true } });
            } else {
                codeContent.innerHTML = finalCodeHtml;
            }

            window.currentCodeBlocks = codeBlocks;
        }

        function copyCode(index) {
            const code = window.currentCodeBlocks[index].code;
            navigator.clipboard.writeText(code);

            const btn = document.querySelectorAll('.copy-btn')[index];
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove('copied');
            }, 2000);
        }

        function init() {
            loadChats();
            setupEventListeners();
            adjustTextareaHeight();
            initVoiceRecognition();
            // set initial ARIA states
            const modeBtn = document.getElementById('modeBtn');
            if (modeBtn) modeBtn.setAttribute('aria-pressed', expertMode ? 'true' : 'false');
            const toggleBtn = document.querySelector('.toggle-sidebar');
            const sidebarEl = document.getElementById('sidebar');
            if (toggleBtn && sidebarEl) toggleBtn.setAttribute('aria-expanded', !sidebarEl.classList.contains('collapsed'));
            // label input for assistive tech
            const input = document.getElementById('messageInput');
            if (input) input.setAttribute('aria-label', 'Message input');
        }

        function setupEventListeners() {
            const input = document.getElementById('messageInput');
            input.addEventListener('input', () => {
                adjustTextareaHeight();
                updateTokenEstimate();
            });
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
        }

        function adjustTextareaHeight() {
            const textarea = document.getElementById('messageInput');
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 240) + 'px';
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const btn = document.querySelector('.toggle-sidebar');
            if (!sidebar) return;
            sidebar.classList.toggle('collapsed');
            const expanded = !sidebar.classList.contains('collapsed');
            if (btn) btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        }

        // NEW: AI Mode Management
        function setAIMode(mode) {
            currentAIMode = mode;
            const buttons = document.querySelectorAll('.ai-mode-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const modeDescriptions = {
                'architect': 'üèóÔ∏è Architecture-focused: SOLID principles, design patterns, scalability',
                'security': 'üîê Security-focused: OWASP, encryption, auth, threat modeling',
                'performance': '‚ö° Performance-focused: Optimization, caching, efficient algorithms',
                'debug': 'üêõ Debug mode: Root cause analysis, comprehensive fixes, test cases'
            };
            
            console.log(`üéØ AI Mode: ${modeDescriptions[mode]}`);
        }

        // NEW: Analysis Panel Toggle
        function toggleAnalysisPanel() {
            const panel = document.getElementById('analysisPanel');
            if (panel) {
                panel.classList.toggle('active');
            }
        }

        // NEW: Analyze generated code
        async function analyzeCode(codeContent) {
            try {
                const analysisPanel = document.getElementById('analysisPanel');
                const analysisContent = document.getElementById('analysisContent');
                
                // Send to backend for analysis
                const response = await fetch(`${NGROK_URL}/analyze-code`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        code: codeContent,
                        mode: currentAIMode
                    })
                }).catch(() => null);

                if (!response || !response.ok) {
                    // Fallback: Client-side quick analysis
                    const analysis = performQuickAnalysis(codeContent);
                    analysisContent.innerHTML = formatAnalysis(analysis);
                    return;
                }

                const analysis = await response.json();
                analysisContent.innerHTML = formatAnalysis(analysis);
            } catch (e) {
                console.warn('Analysis failed:', e);
            }
        }

        // Client-side quick analysis (fallback)
        function performQuickAnalysis(code) {
            const lines = code.split('\n').length;
            const hasErrorHandling = /try|catch|throw|error/i.test(code);
            const hasTypeScript = /:\s*(string|number|boolean|object|any)/i.test(code);
            const hasComments = /\/\//i.test(code) || /\/\*/i.test(code);
            const hasTests = /test|spec|describe|it\(/i.test(code);
            const hasSecurity = /hash|encrypt|jwt|auth|password/i.test(code);
            const hasValidation = /validate|check|verify|assert/i.test(code);

            let quality = 0;
            if (hasErrorHandling) quality += 20;
            if (hasTypeScript) quality += 20;
            if (hasComments) quality += 20;
            if (hasTests) quality += 20;
            if (hasSecurity) quality += 10;
            if (hasValidation) quality += 10;

            return {
                lineCount: lines,
                codeQuality: Math.min(100, quality),
                security: { present: hasSecurity, items: hasSecurity ? ['Authentication/Encryption detected'] : ['Add auth/encryption'] },
                performance: { items: ['Consider caching', 'Monitor database queries'] },
                architecture: { items: currentAIMode === 'architect' ? ['Design patterns applied', 'SOLID principles followed'] : [] },
                issues: hasErrorHandling ? [] : ['Add error handling'],
                coverage: hasTests ? 'Includes tests' : 'Add unit tests'
            };
        }

        // Format analysis for display
        function formatAnalysis(analysis) {
            const qualityClass = analysis.codeQuality >= 80 ? 'excellent' : analysis.codeQuality >= 60 ? 'good' : analysis.codeQuality >= 40 ? 'fair' : 'poor';
            let html = `<span class="code-quality-badge ${qualityClass}">Quality: ${analysis.codeQuality}%</span>`;
            html += `<div style="font-size: 12px; color: var(--text-muted); margin: 8px 0;">Lines: ${analysis.lineCount}</div>`;

            if (analysis.security && analysis.security.items && analysis.security.items.length > 0) {
                html += `<div class="analysis-header" style="margin-top: 12px;">üîê Security</div>`;
                analysis.security.items.forEach(item => {
                    html += `<div class="analysis-item security">${item}</div>`;
                });
            }

            if (analysis.performance && analysis.performance.items && analysis.performance.items.length > 0) {
                html += `<div class="analysis-header" style="margin-top: 12px;">‚ö° Performance</div>`;
                analysis.performance.items.forEach(item => {
                    html += `<div class="analysis-item performance">${item}</div>`;
                });
            }

            if (analysis.architecture && analysis.architecture.items && analysis.architecture.items.length > 0) {
                html += `<div class="analysis-header" style="margin-top: 12px;">üèóÔ∏è Architecture</div>`;
                analysis.architecture.items.forEach(item => {
                    html += `<div class="analysis-item architecture">${item}</div>`;
                });
            }

            if (analysis.issues && analysis.issues.length > 0) {
                html += `<div class="analysis-header" style="margin-top: 12px;">‚ö†Ô∏è Issues</div>`;
                analysis.issues.forEach(item => {
                    html += `<div class="analysis-item issues">${item}</div>`;
                });
            }

            html += `<div style="font-size: 12px; color: var(--text-muted); margin-top: 12px;">Coverage: ${analysis.coverage}</div>`;
            return html;
        }

        function createNewChat() {
            const chatId = Date.now().toString();
            currentChatId = chatId;
            chats[chatId] = {
                id: chatId,
                title: 'New Project',
                messages: [],
                created: new Date().toISOString()
            };
            messageHistory = [];
            uploadedFile = null;
            saveChats();
            renderChatHistory();
            clearChatContainer();
        }

        function loadChat(chatId) {
            currentChatId = chatId;
            const chat = chats[chatId];
            if (!chat) return;
            messageHistory = chat.messages;
            renderMessages();
            renderChatHistory();
        }

        function deleteChat(chatId) {
            delete chats[chatId];
            if (currentChatId === chatId) {
                currentChatId = null;
                clearChatContainer();
            }
            saveChats();
            renderChatHistory();
        }

        function saveChats() {
            if (currentChatId && chats[currentChatId]) {
                chats[currentChatId].messages = messageHistory;
            }
            try {
                localStorage.setItem('codeforge_chats', JSON.stringify(chats));
            } catch (e) {
                console.warn('Storage limit reached');
            }
        }

        function loadChats() {
            try {
                const saved = localStorage.getItem('codeforge_chats');
                if (saved) {
                    chats = JSON.parse(saved);
                    renderChatHistory();
                }
            } catch (e) {
                console.error('Error loading chats:', e);
                chats = {};
            }
        }

        function renderChatHistory() {
            const container = document.getElementById('chatHistory');
            container.innerHTML = '';
            Object.values(chats).sort((a, b) => new Date(b.created) - new Date(a.created)).forEach(chat => {
                const item = document.createElement('div');
                item.className = 'chat-item' + (chat.id === currentChatId ? ' active' : '');

                const titleDiv = document.createElement('div');
                titleDiv.className = 'chat-item-title';
                titleDiv.textContent = chat.title || 'Untitled';
                titleDiv.onclick = () => loadChat(chat.id);

                const delBtn = document.createElement('button');
                delBtn.className = 'delete-chat';
                delBtn.textContent = '‚úï';
                delBtn.onclick = (e) => { e.stopPropagation(); deleteChat(chat.id); };

                item.appendChild(titleDiv);
                item.appendChild(delBtn);
                container.appendChild(item);
            });
        }

        function clearChatContainer() {
            const container = document.getElementById('chatContainer');
            container.innerHTML = `
                <div class="welcome-screen">
                    <h1 class="welcome-title">CodeForge AI Pro</h1>
                    <p class="welcome-subtitle">Production-Grade Code Generation Engine</p>
                    <div class="feature-grid">
                        <div class="feature-card">
                            <div class="feature-title">üèóÔ∏è Complete Projects</div>
                            <div class="feature-desc">Generates full applications with 5000+ lines of production code</div>
                        </div>
                        <div class="feature-card">
                            <div class="feature-title">üîç Expert Debugging</div>
                            <div class="feature-desc">Analyzes and fixes complex bugs with detailed explanations</div>
                        </div>
                        <div class="feature-card">
                            <div class="feature-title">üìã Split View</div>
                            <div class="feature-desc">Code on one side, instructions on the other</div>
                        </div>
                        <div class="feature-card">
                            <div class="feature-title">‚ö° High Performance</div>
                            <div class="feature-desc">Optimized for maximum token output and quality</div>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('instructionsContent').innerHTML = '';
            document.getElementById('codeContent').innerHTML = '';
        }

        function renderMessages() {
            const container = document.getElementById('chatContainer');
            const welcomeScreen = document.getElementById('welcomeScreen');
            if (welcomeScreen) welcomeScreen.remove();
            container.innerHTML = '';
            messageHistory.forEach(msg => {
                appendMessage(msg.role, msg.content, false);
            });
            container.scrollTop = container.scrollHeight;
        }

        function appendMessage(role, content, animate = true) {
            const container = document.getElementById('chatContainer');
            const welcomeScreen = document.getElementById('welcomeScreen');
            if (welcomeScreen) welcomeScreen.remove();

            const messageGroup = document.createElement('div');
            messageGroup.className = 'message-group';

            const message = document.createElement('div');
            message.className = `message ${role}-message`;

            const header = document.createElement('div');
            header.className = 'message-header';
            header.textContent = role === 'user' ? 'üë§ You' : 'ü§ñ CodeForge Pro';

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';

            if (role === 'assistant') {
                messageContent.innerHTML = processMarkdown(content);
                setTimeout(() => {
                    messageContent.querySelectorAll('pre code').forEach((block) => {
                        hljs.highlightElement(block);
                        wrapCodeBlock(block);
                    });
                }, 10);
            } else {
                messageContent.textContent = content;
            }

            message.appendChild(header);
            message.appendChild(messageContent);
            messageGroup.appendChild(message);
            container.appendChild(messageGroup);
            container.scrollTop = container.scrollHeight;
            return messageContent;
        }

        function wrapCodeBlock(codeElement) {
            const pre = codeElement.parentElement;
            if (pre.previousElementSibling?.className === 'code-header') return;

            const header = document.createElement('div');
            header.className = 'code-header';

            const language = codeElement.className.match(/language-(\w+)/)?.[1] || 'code';
            const langSpan = document.createElement('span');
            langSpan.className = 'code-language';
            langSpan.textContent = language;

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.onclick = () => {
                navigator.clipboard.writeText(codeElement.textContent);
                copyBtn.textContent = 'Copied!';
                copyBtn.classList.add('copied');
                setTimeout(() => {
                    copyBtn.textContent = 'Copy';
                    copyBtn.classList.remove('copied');
                }, 2000);
            };

            header.appendChild(langSpan);
            header.appendChild(copyBtn);
            pre.parentElement.insertBefore(header, pre);
        }

        function showThinking(message = 'Generating production code...') {
            const container = document.getElementById('chatContainer');
            const welcomeScreen = document.getElementById('welcomeScreen');
            if (welcomeScreen) welcomeScreen.remove();

            const messageGroup = document.createElement('div');
            messageGroup.className = 'message-group';
            messageGroup.id = 'thinkingMessage';

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';

            const header = document.createElement('div');
            header.className = 'message-header';
            header.textContent = 'ü§ñ CodeForge Pro';

            const thinkingContainer = document.createElement('div');
            thinkingContainer.className = 'thinking-container';
            thinkingContainer.innerHTML = `
                <div class="thinking-dots">
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                </div>
                <div class="thinking-text">${message}</div>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
            `;

            messageDiv.appendChild(header);
            messageDiv.appendChild(thinkingContainer);
            messageGroup.appendChild(messageDiv);
            container.appendChild(messageGroup);
            container.scrollTop = container.scrollHeight;
        }

        function removeThinking() {
            const thinking = document.getElementById('thinkingMessage');
            if (thinking) thinking.remove();
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                uploadedFile = {
                    name: file.name,
                    content: e.target.result,
                    type: file.type
                };
                console.log('File uploaded:', uploadedFile.name);
            };
            reader.readAsText(file);
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message && !uploadedFile) return;
            if (isGenerating) return;

            if (!currentChatId) createNewChat();

            let fullMessage = message;
            if (uploadedFile) {
                fullMessage = `File: "${uploadedFile.name}"\n\n${message}\n\n--- FILE CONTENT ---\n${uploadedFile.content}`;
            }

            input.value = '';
            adjustTextareaHeight();
            updateTokenEstimate();

            messageHistory.push({ role: 'user', content: message });
            appendMessage('user', message);

            // Detect explicit large-generation requests like "2000 lines" and confirm
            const largeMatch = message.match(/\b(\d{3,6})\s*(lines|lines of code)\b/i);
            if (largeMatch) {
                const linesRequested = largeMatch[1];
                const proceed = confirm(`You requested ${linesRequested} lines of code ‚Äî that's a very large output.\n\nPress OK to proceed with full generation (will be generated iteratively), or Cancel to receive a scaffold and clarifying questions instead.`);
                if (!proceed) {
                    appendMessage('assistant', `I detected you requested ${linesRequested} lines. Before generating such a large output, I can: 1) Provide a detailed scaffold and architecture, 2) Ask clarifying questions about features, pages, styling, and tech stack, or 3) Generate the project in iterative chunks. Which would you prefer?`);
                    // Restore UI state and abort generation for now
                    document.getElementById('sendBtn').disabled = false;
                    return;
                } else {
                    // Mark the message to indicate user confirmed large-generation (used by buildPrompt)
                    fullMessage = `[LARGE_GENERATION_CONFIRMED:${linesRequested}] ` + fullMessage;
                }
            }

            if (messageHistory.length === 1) {
                chats[currentChatId].title = message.substring(0, 60) + (message.length > 60 ? '...' : '');
                renderChatHistory();
            }

            isGenerating = true;
            document.getElementById('sendBtn').disabled = true;
            document.getElementById('sendBtn').setAttribute('aria-busy', 'true');

            const enhancedPrompt = buildPrompt(fullMessage);
            // Update UI badge to reflect whether this request will be treated as Chat or Code
            try {
                const badge = document.getElementById('replyModeBadge');
                if (lastRequestIsCode) {
                    badge.textContent = 'Code';
                    badge.classList.add('code');
                    badge.classList.remove('chat');
                } else {
                    badge.textContent = 'Chat';
                    badge.classList.add('chat');
                    badge.classList.remove('code');
                }
            } catch (e) { /* ignore UI update errors */ }

            try {
                await streamResponse(enhancedPrompt);
                if (uploadedFile) {
                    uploadedFile = null;
                    document.getElementById('fileInput').value = '';
                }
            } catch (error) {
                console.error('Error:', error);
                removeThinking();
                appendMessage('assistant', `‚ùå **Error**: ${error.message}\n\nPlease check that servers are running with: \`python run_codeforge.py\``);
                isGenerating = false;
                document.getElementById('sendBtn').disabled = false;
                document.getElementById('sendBtn').removeAttribute('aria-busy');
            }
        }

        // ---------------------- CALL PROJECT GENERATOR ----------------------
        async function callProjectGenerator(type, name, lines) {
            try {
                const res = await fetch("http://localhost:5050/generate-project", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        projectType: type,
                        projectName: name,
                        minLines: lines
                    })
                });

                const data = await res.json();
                console.log("Project Generator Result:", data);

                // Display in chat window via appendMessage
                appendMessage('assistant', 'Project generated:\n\n' + JSON.stringify(data, null, 2));
            } catch (e) {
                console.error('Project generator error:', e);
                appendMessage('assistant', '‚ùå Error generating project: ' + e.message);
            }
        }


        function buildPrompt(userMessage) {
            let prompt = EXPERT_SYSTEM_PROMPT + '\n\n';

            // Add mode-specific guidance
            const modeGuidance = {
                'architect': `\n[ARCHITECT MODE ACTIVE] Focus on: System design, scalability, SOLID principles, design patterns, clean architecture, microservices where applicable.\n`,
                'security': `\n[SECURITY MODE ACTIVE] Focus on: OWASP compliance, authentication/authorization, encryption, input validation, secure coding practices, threat modeling.\n`,
                'performance': `\n[PERFORMANCE MODE ACTIVE] Focus on: Algorithm efficiency, caching strategies, database optimization, lazy loading, code splitting, memory optimization.\n`,
                'debug': `\n[DEBUG MODE ACTIVE] Focus on: Root cause analysis, comprehensive fixes, prevention strategies, test cases, edge cases, thorough explanations.\n`
            };

            prompt += modeGuidance[currentAIMode] || modeGuidance['architect'];

            if (messageHistory.length > 1) {
                const context = messageHistory.slice(-6, -1).map(m =>
                    `${m.role === 'user' ? 'USER' : 'ASSISTANT'}: ${m.content}`
                ).join('\n\n');
                prompt += `CONVERSATION HISTORY:\n${context}\n\n`;
            }

            prompt += `USER REQUEST: ${userMessage}\n\n`;

            // If user explicitly confirmed a very large generation, instruct the model to generate iteratively
            const largeConfirmMatch = userMessage.match(/\[LARGE_GENERATION_CONFIRMED:(\d+)\]/i);
            if (largeConfirmMatch) {
                const linesTarget = largeConfirmMatch[1];
                lastRequestIsCode = true;
                prompt += `ASSISTANT: The user has CONFIRMED generation of ${linesTarget} lines. Proceed by first providing a high-level scaffold and file/folder plan, then generate the project iteratively in well-labeled chunks (e.g., Part 1/10). For each chunk, include filenames, code blocks, and brief tests. Do not produce uncontrolled monolithic output ‚Äî break into manageable parts and wait for user "continue" or confirmation between major sections.\n\n`;
                return prompt;
            }

            // Smart detection: is this casual chat or code request?
            const casualGreetings = /^(hi|hey|hello|yo|what's up|how are you|how's it going|thanks|thank you|no problem|sounds good|who are you|what do you do)$/i;
            const codeKeywords = /\b(build|create|generate|code|implement|make|write|develop|design|fix|refactor|improve|optimize|help|show|can you|let me)\b/i;
            const wordCount = userMessage.trim().split(/\s+/).length;
            const isSimpleGreeting = wordCount <= 3 && casualGreetings.test(userMessage.trim());
            const hasCodeKeywords = codeKeywords.test(userMessage);

            // Determine mode and set global flag for streaming logic
            if (isSimpleGreeting && !hasCodeKeywords) {
                lastRequestIsCode = false;
                prompt += `ASSISTANT: `; // conversational
            } else if (hasCodeKeywords || wordCount > 6 || /```/.test(userMessage)) {
                lastRequestIsCode = true;
                prompt += `ASSISTANT: I'll generate superior, production-ready code with comprehensive ${currentAIMode}-focused excellence.\n\n`;
            } else {
                lastRequestIsCode = false;
                prompt += `ASSISTANT: `;
            }

            return prompt;
        }

        async function streamResponse(prompt) {
            // Use the global flag set by buildPrompt to determine chat vs code streaming behavior
            const isCode = !!lastRequestIsCode;
            const isLongRequest = prompt.length > 500 || isCode;
            const thinkingMsg = isCode ? 'Generating production code... (this may take a while)' : 'Processing request...';
            showThinking(thinkingMsg);

            const container = document.getElementById('chatContainer');
            const messageGroup = document.createElement('div');
            messageGroup.className = 'message-group';

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';

            const header = document.createElement('div');
            header.className = 'message-header';
            header.textContent = isCode ? 'ü§ñ CodeForge Pro ‚Äî CODE' : 'ü§ñ CodeForge Pro ‚Äî CHAT';

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.id = 'streamingContent';

            messageDiv.appendChild(header);
            messageDiv.appendChild(messageContent);
            messageGroup.appendChild(messageDiv);

            let fullText = '';

            try {
                removeThinking();
                container.appendChild(messageGroup);
                container.scrollTop = container.scrollHeight;

                // Choose n_predict and sampling params based on mode
                const nPredict = isCode ? (expertMode ? 24000 : 16000) : (expertMode ? 8000 : 4000);
                const temperature = isCode ? 0.2 : 0.7;
                const top_p = isCode ? 0.85 : 0.9;
                const top_k = isCode ? 40 : 50;

                const response = await fetch(`${NGROK_URL}/stream`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        n_predict: nPredict,
                        temperature: temperature,
                        top_p: top_p,
                        top_k: top_k,
                        repeat_penalty: isCode ? 1.05 : 1.0,
                        min_p: isCode ? 0.1 : 0.0,
                        typical_p: isCode ? 0.95 : 0.8,
                        tfs_z: isCode ? 1.0 : 0.0,
                        mirostat: 0,
                        stop: [
                            '\nUSER:',
                            '\nUser:',
                            'USER REQUEST:',
                            '\n\nUSER REQUEST:'
                        ]
                    })
                });

                if (!response.ok) {
                    throw new Error(`Stream failed: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (!line.trim() || !line.startsWith('data: ')) continue;

                        const jsonStr = line.substring(6).trim();
                        if (jsonStr === '[DONE]') continue;

                        try {
                            const data = JSON.parse(jsonStr);
                            if (data.content) {
                                fullText += data.content;
                                messageContent.innerHTML = processMarkdown(fullText);

                                // Optimize rendering: batch highlight updates every 500ms to avoid lag
                                if (!window.highlightTimeout) {
                                    window.highlightTimeout = setTimeout(() => {
                                        messageContent.querySelectorAll('pre code').forEach((block) => {
                                            if (!block.classList.contains('hljs')) {
                                                hljs.highlightElement(block);
                                                wrapCodeBlock(block);
                                            }
                                        });
                                        window.highlightTimeout = null;
                                    }, 300);
                                }

                                if (currentView === 'split') {
                                    updateSplitView(fullText);
                                }

                                container.scrollTop = container.scrollHeight;
                            }
                        } catch (e) {
                            // Skip malformed JSON
                        }
                    }
                }

                messageHistory.push({ role: 'assistant', content: fullText });
                saveChats();

            } catch (error) {
                console.error('Streaming error:', error);
                throw error;
            } finally {
                isGenerating = false;
                const sendBtn = document.getElementById('sendBtn');
                if (sendBtn) {
                    sendBtn.disabled = false;
                    sendBtn.removeAttribute('aria-busy');
                }
                // Trigger analysis on generated code
                setTimeout(() => analyzeCode(fullText), 500);
            }
        }

        console.log('üéØ CodeForge Pro v2.5 - Expert Edition');
        console.log('üåä Maximum code generation enabled');
        console.log('üì° Server:', NGROK_URL);
        init();
    </script>
</body>

</html>